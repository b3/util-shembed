#!/usr/bin/env bash
# Embed file in shell script.
#
# usage: script [ACTIONS|OPTIONS] SCRIPT
#
# This script deals with file included in shell script between two surrounding
# lines of the form
#
#     # begin FILENAME ENC
#     # end FILENAME
#
# where ENC is optional and represents a specific encoding (base64).
#
# The 'begin' word may be suffixed by tags as a list of words, each prefixed
# by a dash.
#
# In order to avoid shell conflicts, these lines are generally inserted after
# an explicit 'exit 0'.
#
# If no action option is specified then '-l' is implied. If more than one is
# specified only the last one on command line is processed.
#
# ACTIONS
#     -a, --add FILE       embed FILE at the end of SCRIPT or by replacing the
#                          last '# include FILENAME' line by its content
#     -u, --update FILE    update the embedded FILE in SCRIPT
#     -U, --update-all     update all embedded files (must be in current dir)
#     -l, --list           list embedded files
#     -x, --extract FILE   extract FILE
#     -X, --extract-all    extract all files
#     -s, --shell          show shell functions to include in script
#     -h, --help           show this help message
#
# OPTIONS
#     -b, --base64         use base64 instead of cat when adding
#     -t, --tag STRING     add STRING as tag (maybe used many times)

# Copyright (C) 2016,2018 Bruno BEAUFILS <bruno@boulgour.com>
#
# This software comes with ABSOLUTELY NO WARRANTY.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation in its version 2.
#
# See the README or COPYING file for details.

# TODO: acknowledge that there may not be two files of the same name

ACTION=list_files
ENCODE=raw

# doc is commented at the beggining of the script until first empty line
doc () { sed -n '2,/^$/ { s/^ *#// ; s/^ //g ; t ok ; d ; :ok ; p }' <$0 ; }

# die with an error message
die () { echo "$(basename $0): error: $*" 1>&2 ; exit 1 ; }

# run a command silently
mute () { 1>/dev/null 2>&1 $* ; }

# warn absence of $1, last parm may be used for listing needed debian packages
need () { die "$1 is unavailable" ; }

# verify if needed tools are available
vrfy ()
{
    mute which base64 || need base64
}

# add $2 in $1 encoded as $3 eventually using $4 as tags
add_file ()
{
    f=$(basename $2)

    list_files $1 | grep -q $2 && die "file already included"
    
    if [ "x$3" = "xbase64" ] ; then
        t=$(mktemp)
        base64 "$2" > "$t"
        set "$1" "$t" "$3" "$4"
    else
        set "$1" "$2" "" "$4"
    fi

    l=$(sed -n '/^# include '"$f"' *$/ =' "$1" | tail -1)
    if [ -z "$l" ] ; then
        l='$' ; cmd=
    else
        cmd="-e ${l}d"
    fi

    sed -i \
        -e "$l"' a\# begin'"$4"' '"$f"' '"$3" \
        -e "$l"' r '$2\
        -e "$l"' a\# end '"$f" \
        $cmd \
        $1

    [ $t ] && rm $t 
}

# update $2 in $1
update_file ()
{
    f=$(basename $2)

    enc=$(sed -nr 's/^# begin(-[^- ]+)* '"$f"' (.*)$/\2/; t o; b; :o p' "$1")
    if [ "x$enc" = xbase64 ] ; then
        t=$(mktemp)
        base64 "$2" > "$t"
        set "$1" "$t"
    fi

    tags=$(sed -nr 's/^# begin((-[^- ]+)*) '"$f"' .*$/\1/; t o; b; :o p' "$1")
    
    sed -i -r \
        -e '/^# begin'"$tags"' '"$f"'($| .*$)/ a\# begin+tmp'"$tags"'' \
        -e '/^# end '"$f"' *$/ i\# end+tmp' \
        "$1"
    sed -i -r \
        -e '/^# begin\+tmp/,/^# end\+tmp$/ d' \
        -e '/^# begin'"$tags"' '"$f"'($| .*$)/ r '"$2" \
        "$1"
        
    [ $t ] && rm $t 
}

# extract $2 from $1
extract_file ()
{
    enc=$(sed -nr 's/^# begin(-[^- ]+)* '"$2"' (.*)$/\2/; t o; b; :o p' "$1")
    cmd=cat
    [ x$enc = xbase64 ] && cmd="base64 -d"

    tags=$(sed -nr 's/^# begin((-[^- ]+)*) '"$2"' .*$/\1/; t o; b; :o p' "$1")
    
    sed -nr '/^# begin'"$tags"' '"$2"'($| .*$)/,/^# end '"$2"'$/ p' "$1" \
        | sed '1d ; $d' \
        | $cmd > "$2"
}

# list files embedded in $1
list_files ()
{
    grep '^# begin' $1 | sed -re 's/^# begin((-[^- ]+)*) ([^ ]+)($| .*$)/\3/'
}

# Args processing
while [ -n $1 ]
do
    case "$1" in
        "-a"|"--add") ACTION=add_file ; shift ; FILE=$1 ;;
        "-u"|"--update") ACTION=update_file ; shift ; FILE=$1 ;;
        "-U"|"--update-all") ACTION=update_all ;;
        "-l"|"--list") ACTION=list_files ;;
        "-x"|"--extract") ACTION=extract_file ; shift ; FILE=$1 ;;
        "-X"|"--extract-all") ACTION=extract_all ;;
        "-s"|"--shell") declare -f list_files extract_file ; exit 0 ;;
        "-b"|"--base64") ENCODE=base64 ;;   
        "-h"|"--help") doc ; exit 0 ;;
        "-t"|"--tag")
            shift
            [ -z "$1" ] && die "missing tag"
            TAGS="$TAGS-$(tr -d ' -' <<< $1)"
            ;;
        *) break ;;
    esac
    shift
done
SCRIPT=$1

# Common checks
vrfy || die "needed tools are missing"
[ -z $SCRIPT ] && die "no script specified"
[ $# -gt 1 ] && die "too many script specified"
[ "$ACTION" != "add_file" -a -n "$TAGS" ] && die "-t can only be used when adding files"
    
# Action
case "$ACTION" in
    "add_file"|"update_file")
        [ -z "$FILE" ] && die "no file specified"
        [ ! -r "$FILE" ] && die "cannot read $FILE"
        $ACTION "$SCRIPT" "$FILE" "$ENCODE" "$TAGS"
        ;;
    "extract_file")
        [ -z "$FILE" ] && die "no file specified"
        $ACTION "$SCRIPT" "$FILE"
        ;;
    "update_all")
        list_files "$SCRIPT" | while read file
        do
            update_file "$SCRIPT" "$file"
        done
        ;;
    "extract_all")
        list_files "$SCRIPT" | while read file
        do
            extract_file "$SCRIPT" "$file"
        done
        ;;
    "list_files"|*)
        list_files "$SCRIPT"
        ;;
esac

exit 0
